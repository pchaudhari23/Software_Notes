NODE:

- Javascript **runtime environment** which runs on **Google** **chrome's V8 javascript engine**.
- Executes **outside** the browser.
- **Single threaded**: It executes one main thread sequentially so the code runs line by line.
- **Event loop:** Async tasks are handled by the **event loop** , so the main thread never blocks.
- Has **Non blocking I/O**: Uses **libuv** library to perform I/O operations.
- **Worker threads:** For CPU-heavy tasks, Node.js supports **worker threads** to run JavaScript in **parallel** from a thread pool.
- **Event driven**: Supports **asynchronous code** execution - Uses promises, callbacks and async/await.
- Has **built in modules** for various functionalities - like file handling, encryption, data fetching etc.
- Modules are written in JavaScript & C++ language
- Cross platform, Rich ecosystem, Scalable, real time applications
- Free, open-source
- Current version: v24.x (Dec 2025)

---

EXPRESS:

- Fast, lightweight, minimalist framework
- Buidiling **web applications** and **APIs** with Node js
- Supports **middlewares** to intercept and process requests and responses
- express.json() for JSON and express.static() for serving static files
- Supports **routing**
- Supports templating engines
- RESTful API Development
- Static file serving
- Unopinionated - so we don't have to follow a fixed project structure
- Current version: v5.x (Dec 2025)

---

Mongo DB:

- MongoDB is a **distributed, document-oriented NoSQL** database storing data in **JSON-like documents**.
- **It i**nternally stores data in **Binary JSON (BSON)** , a binary-encoded format that is faster to parse and supports more data types than JSON.
- It uses a **flexible, schema-less design** so that we can use dynamic data structures. Although we can put **schema validation** using **Mongoose**.
- **High availability** - achieved through replica sets that provide automatic failover and redundancy.
- **Horizontal scaling** - done using sharding to distribute data across multiple servers for large workloads.
- **Aggregation pipeline** - a powerful framework to transform, filter, and analyze data in stages.
- **ACID transactions** - supported since MongoDB 4.0 for multi-document operations, ensuring atomicity, consistency, isolation, and durability.
- **Rich indexing** - supports text, geospatial, compound, and other indexes for faster query performance.
- Current version: v7.x (Dec 2025)

---

JAVASCRIPT ENGINE: Execute JavaScript programs

- Chrome - V8
- Firefox - SpiderMonkey
- Apple Safari - JavaScriptCore/Nitro
- Microsoft Edge - Chakra

---

How it works:

1. Parsing: Source code is parsed and converted into AST (Abstract Syntax Tree).
2. Bytecode Generation: The AST is used to generate bytecode (an intermediate representation).
3. Interpretation: The bytecode is excuted line by line by the engine.
4. JIT Compilation: Frequently executed code/ hot code is optimized and compiled into machine code using Just-In-Time (JIT) compilation. This improves performance.
5. Execution: Synchronous code is excuted immediately and event loop manages the order of execution for async code. JavaScript engine has a call stack, two queues and a heap.

---

COMPONENTS:

1. Call stack: Executes synchronous function calls.
2. Microtask queue: High priority asynchronous task - Promises, then & catch, async & await, fetch (itself is synchronous, but returns a promise whose resolution then or catch goes into microtasks).
3. Macrotask queue/Task queue: Low priority asynchronous task - Web API (Browser), setTimeout, setInterval, DOM events (click, scroll etc.), I/O events, setImmediate (Node.js).
4. Heap: Memory area where JavaScript stores dynamically allocated data. Stores objects, arrays, functions, closure, class instance etc and is managed by garbage collector.

---

EVENT LOOP:

1. Execute all synchronous code first in the call stack until it’s empty
2. Execute all microtasks (drain the microtask queue completely)
3. Execute only one macrotask - handled by browser/web API
4. After each macrotask, check and run all microtasks again before the next macrotask
5. Repeat

---

CODE:

```javascript
console.log(1); // synchronous code

setTimeout(() => {
  console.log(2); // macrotask queue
}, 0);

Promise.resolve().then(() => {
  console.log(3); // microtask queue
});

console.log(4); // synchronous code
```

OUTPUT: 1 4 3 2

---

PARALLEL EXECUTION:

- JavaScript is single-threaded: only one piece of JavaScript runs at a time per runtime.
- Asynchronous operations are queued, and the event loop co-ordinates the callback execution.
- Async work itself (timers, network, I/O, crypto, etc.) is handled outside JavaScript’s main thread by the browser/Node runtime or OS.

Browser: Web workers - allow true parallel execution of JavaScript.

- Each thread is its own JavaScript runtime having their own call stack, task queues (microtask & macrotask), heap and event loop.
- Communicates with main thread via message passing (postMessage).
- Cannot access DOM directly.

Node.js: Worker threads - provide parallel execution for CPU-heavy tasks.

- Each thread is its own JavaScript runtime having their own call stack, task queues (microtask & macrotask), heap and event loop.
- Communicates via message channels (parentPort, postMessage).
- Can share memory explicitly via SharedArrayBuffer.
- Node also uses libuv’s thread pool for async I/O (file system, DNS, crypto), but those threads don’t run JavaScript — they just handle background work.

---
