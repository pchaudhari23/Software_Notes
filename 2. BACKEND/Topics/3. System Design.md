LLD: Low Level Design

---

HLD: High Level Design

---

CLEAN ARCHITECTURE:

- Software design philosphy by Robert Martin (Uncle Bob).
- Separation of concerns: Build scalable, maintainable, testable applications.
- Dependency rule: Dependencies point inward (Dependency Inversion). Outer layers can depend on inner layers, but inner layers should never know anything about outer layers.
- Follows SOLID principles, DRY, and YAGNI, with loose coupling and high cohesion.
- Clean architecture is software application architecture/ layout & MVC is a design pattern.

Layers:
Layer 1 - Frameworks & Drivers (outermost)
Layer 2 - Interface Adapters
Layer 3 - Use Cases (Application Business Rules)
Layer 4 - Entities - Enterprise Business Rules (innermost)

Node Related:
Controllers:

- Contains HTTP logic
- Belongs to Layer 2: Interface Adapters

Repository/ Data Access Layer (DAL):

- Contains DB queries.
- Talks directly to db, contains all queries keeping db logic out of controllers or models.
- Repository interface/abstraction belongs to layer 2
- Repository concrete implementation belongs to layer 1

Service:

- Contains business logic, orchestrates multiple repositories.
- Belongs to Layer 3: Use Cases

Flutter Related:
Project Folder Structure
a. lib/
i. core/ → reusable utilities (network, errors, constants, routes, helpers).
ii. features/ → feature-based modules (login, checkout, payments, etc.).
b. Each feature contains:
i. presentation/ (Bloc, Pages, Widgets)
ii. domain/ (Usecases, Entities, Repositories)
iii. data/ (Datasources, Models, Repository Implementations)
iv. feature-level dependency injection file

1. Domain Layer (Business Rules)
   a. UseCases: single responsibility classes with a call() method.
   b. Repositories (abstract): define contracts, return Future<Either<Failure,
   Entity>>.
   c. Entities: plain Dart classes representing business objects (no JSON, no
   framework code).
2. UseCase Pattern
   a. Input: Params or NoParams from Bloc.
   b. Output: Either<Failure, Entity>.
   c. Encapsulates one specific business action (e.g., GetUser, Login, FetchOrders).
3. Data Layer Responsibilities
   a. Datasources: handle API calls, caching, database access.
   i. Defined as abstract + concrete implementation.

b. Models:
i. Extend Entities.
ii. Contain fromJson, toJson, and factory constructors.

c. Repository Implementations:
i. Implement domain repositories.
ii. Convert Models ↔ Entities.
iii. Handle Left(Failure) and Right(Data) responses.

4. Data Flow in Action
   a. UI → Bloc → UseCase → Repository → Datasource → API
   b. API response → Model → Repository → Entity → UseCase → Bloc → UI
   c. Ensures UI never depends directly on data sources or models.

- Call flow goes downward, while data flow goes upward.

5. Presentation Layer
   a. Bloc:
   i. Receives UI events.
   ii. Calls UseCases.
   iii. Emits states.
   b. Pages: screen-level UI.
   c. Widgets: reusable UI components.
   d. UI logic stays thin; business logic stays out of widgets.

TDD (Test-Driven Development) Workflow:

1. Write tests before implementation.
2. Mirror lib/ structure inside test/.
3. Use Arrange → Act → Assert.
4. Mock dependencies with Mockito.
5. JSON fixtures provide predictable dummy data for tests.

Key Libraries:

1. get_it → dependency injection (service locator).
2. flutter_bloc → state management.
3. equatable → value equality for entities and states.
4. dartz → functional programming (Either, Left, Right).
5. http, data_connection_checker_nulls → remote API handling.
6. shared_preferences → local caching.

---

MODEL VIEW CONTROLLER:

- MVC is a design pattern that separates an application into Model, View, and Controller.
- The Model manages data, business rules, and application logic.
- Models are typically defined using Mongoose, which maps MongoDB documents to JavaScript objects.
- The Model handles database operations like CRUD, schema validation, and business logic.
- MongoDB’s schema-less nature fits well with MVC, allowing flexible model evolution.
- The same Model can be reused for multiple Views, such as web pages and API responses.
- The View is responsible only for presenting data to the user.
- Views are built using HTML and CSS, often with templating engines like EJS or Handlebars.
- Client-side JavaScript enhances the View with dynamic behavior and DOM manipulation.
- The Controller handles user input and coordinates between the Model and View.
- Controllers receive requests from the frontend, process data, and return responses or rendered views.
- In a Node.js application, Express acts as the Controller layer, handling routes and HTTP requests.
- Middleware in Express integrates smoothly with MVC for authentication, logging, and validation.
- MVC helps keep routing logic separate from database queries, improving maintainability.
- Using MVC in Express makes APIs cleaner and more modular, especially for RESTful services.
- This separation improves code organization and readability.
- MVC makes applications easier to maintain and scale, making it easier to add new features or endpoints.
- Overall, MVC enables clean architecture, faster development, and easier collaboration.

---

Software Requirement specifications:

- Design thinking
- System design - Design patterns
- Tech stack used: Which technology and cloud platforms to use as per requirment
- System Architecture
- Microservices vs monolithic architecture
- Frontend design - UI/UX
- Backend design - API design
- ER diagrams - Class based backend technology and Structured databases.
- Database design - All Tables and columns and connections
- Modularized application - OOPs
- OOP is very useful on large scale projects, as it facilitates code modularity and organization
- Large scale, complex, enterprise applications - Use Angular + .NET + Relational DB as tech stack?
- Startups, Small applications - User MERN Stack as tech stack?
