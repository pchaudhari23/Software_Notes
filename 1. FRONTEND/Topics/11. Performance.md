WHEN USER VISITS A WEBSITE:

1. End user: Clicks on link or enters the website name in browser URL bar. DNS resolution is done to find out the server IP and HTTP connection is made.
2. Browser request: Send request to web server.
3. Server response: Single HTML file (index.html) is returned. Contains minimal code - 1. div containing id="root", 2. script tag which loads the react javascript bundle - main.js, 3. link tag to load the css which is optional.
4. Browser parsing and download: HTML is parsed in the browser. At the same time, Javascript and CSS bundles and static assets like images, CSS, fonts, icons, json files etc. are downloaded. These files come from the same build folder generated during the build process.
5. Javascript parsing and execution: React and react DOM are initialized. Components imported and Code like `ReactDOM.createRoot(document.getElementById('root')).render(<App />)` runs. Downloaded static assets are loaded as and when required.
6. React bootstrap: The app creates the virtual DOM and renders the root component into the actual DOM.
7. State initialization, data fetching, routing and dynamic component rendering begin

---

1. Memoization
   - React.memo (for components) - higher-order component (HOC)
   - useMemo (for values or computations within a component)
   - useCallback (to memoize functions within a component)
1. Debouncing
1. Lazy loading

---

CSR: Client Side Rendering

- **Browser** does the **rendering** - the server sends a basic HTML shell and a **JavaScript bundle** .
- The browser downloads the JS, fetches data, and **builds the UI dynamically** .
- This shifts the work to the **client**, so **initial load** can be slower.
- Once rendered, JavaScript handles all interactions and navigation.
- Good for SPAs but bad for SEO because the page does not have content as content is loaded in the browser after the user visits the website.

---

SSR: Server Side Rendering

- **Server renders full HTML** page **for every request** and sends it to browser.
- User **makes request, server fetches data** and **renders** React components to HTML.
- Complete HTML arrives at browser ready to display, improving **first paint**.
- Then **hydration** happens which means adding interactivity and event listeners to static HTML.
- Server workload is higher because rendering happens **per request** .
- Great for **SEO-heavy** pages like **blogs**, **marketing sites**, or **product pages.**

---

SSG: Static Site Generation

- HTML pages are **pre-generated** at build time and served as static files.
- Build process **generates every page upfront** so it can be very long, but website is faster on client.
- **CDN** serves pre-built HTML instantly when users request pages (fastest delivery).
- Pages are static and if something is updated, **a manual rebuild** is required to see changes.
- Best for: blogs, documentation, marketing websites where content does not change often and hence frequent builds are not required.

---

ISR: Incremental Static Regeneration

- Combines static generation with **on-demand regeneration** after **specified time intervals.**
- Initial build creates static pages, serves them like SSG.
- After revalidation period **expires**, next request **triggers background regeneration.**
- Users get stale page instantly while **fresh version builds and replaces it.**
- Best for: e-commerce with product catalogs, news sites needing freshness without constant rebuilds.

---

STATIC WEBSITE:

- HTML, CSS, JS
- Web page may not necessarily be static. The page content might change by DOM updates.
- But the source code is same. The files used in website are same.

---

DYNAMIC WEBSITE:

- Web servers support server side scripting languages - Active Server Pages (ASP), Javascript (Node JS), PHP, Python, and Ruby.
- Web page is created in the server and then delivered to client. Server side rendering.
- Users see different content every time they use the application. Eg: YouTube

---

Lazy Loading:

- Don't load the complete assets of the webpage such as images beforehand, just load the necessary data required to display the page.
- Load the static assets when it is required. Be "lazy" while loading the page, do only what is necessary.
- Lazy loading is also used in caching. The data is filled in cache only when it is required avoiding unnecessary filling of data that is not requested.

---
