Here are some of the most common React errors, mistakes, and their solutions:

## 1. **Too Many Re-renders**
**Error**: "Error: Too many re-renders. React limits the number of renders to prevent an infinite loop."

**Cause**: Calling state setter directly in render body
```jsx
// WRONG - causes infinite loop
function Component() {
  const [count, setCount] = useState(0);
  setCount(count + 1); // Called during render
  return <div>{count}</div>;
}
```

**Solution**: Use effects or event handlers
```jsx
// RIGHT
function Component() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    // Or call from event handler
  }, []);
  
  return <div>{count}</div>;
}
```

## 2. **Missing Dependency in useEffect**
**Cause**: Forgetting dependencies in dependency array
```jsx
// WRONG - missing dependency
useEffect(() => {
  fetchData(userId);
}, []); // Missing userId dependency
```

**Solution**: Add all dependencies or use proper cleanup
```jsx
// RIGHT
useEffect(() => {
  fetchData(userId);
}, [userId]); // Include all dependencies

// OR use callback with cleanup
useEffect(() => {
  let isMounted = true;
  
  const fetchData = async () => {
    const result = await apiCall(userId);
    if (isMounted) setData(result);
  };
  
  fetchData();
  
  return () => { isMounted = false; };
}, [userId]);
```

## 3. **Mutating State Directly**
**Error**: Component doesn't re-render when state changes

**Cause**: Modifying state directly instead of using setter
```jsx
// WRONG
const [user, setUser] = useState({ name: 'John' });
user.name = 'Jane'; // Direct mutation
setUser(user); // Reference hasn't changed
```

**Solution**: Create new object/array
```jsx
// RIGHT
setUser({ ...user, name: 'Jane' });

// For arrays
setItems([...items, newItem]);
setItems(items.filter(item => item.id !== id));
```

## 4. **Missing Key Prop in Lists**
**Warning**: "Warning: Each child in a list should have a unique 'key' prop."

**Cause**: Rendering list without keys
```jsx
// WRONG
{items.map(item => <li>{item.name}</li>)}
```

**Solution**: Use unique, stable keys (not index if possible)
```jsx
// RIGHT
{items.map(item => (
  <li key={item.id}>{item.name}</li>
))}
```

## 5. **Async State Update Issues**
**Problem**: Using stale state in async operations
```jsx
// WRONG - uses stale count
const handleClick = async () => {
  await apiCall();
  setCount(count + 1); // Might use outdated count
};
```

**Solution**: Use functional update or refs
```jsx
// RIGHT - functional update
setCount(prevCount => prevCount + 1);

// OR using ref for latest value
const countRef = useRef(count);
useEffect(() => {
  countRef.current = count;
}, [count]);
```

## 6. **Memory Leaks**
**Cause**: Not cleaning up subscriptions, timeouts, or event listeners
```jsx
// WRONG
useEffect(() => {
  const interval = setInterval(() => {
    // do something
  }, 1000);
  // Missing cleanup
}, []);
```

**Solution**: Always return cleanup function
```jsx
// RIGHT
useEffect(() => {
  const interval = setInterval(() => {
    // do something
  }, 1000);
  
  return () => clearInterval(interval);
}, []);
```

## 7. **Incorrect Event Handling**
**Problem**: Calling function immediately instead of passing reference
```jsx
// WRONG - calls immediately
<button onClick={handleClick()}>Click</button>

// WRONG - infinite re-render in class component
<button onClick={this.setState({ clicked: true })}>Click</button>
```

**Solution**: Pass function reference
```jsx
// RIGHT
<button onClick={handleClick}>Click</button>

// For passing parameters
<button onClick={() => handleClick(id)}>Click</button>
// OR use data attributes or bind
```

## 8. **Conditional Hooks Violation**
**Error**: "React Hook 'useState' is called conditionally"

**Cause**: Hooks called conditionally or after early returns
```jsx
// WRONG
if (condition) {
  const [state, setState] = useState();
}
```

**Solution**: Always call hooks at the top level
```jsx
// RIGHT
const [state, setState] = useState();
if (condition) {
  // Use state
}
```

## 9. **Forgetting useMemo/useCallback Dependencies**
**Problem**: Unnecessary re-renders or stale closures
```jsx
// WRONG - missing dependencies
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), []);
const callback = useCallback(() => doSomething(a, b), []);
```

**Solution**: Include all dependencies
```jsx
// RIGHT
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
const callback = useCallback(() => doSomething(a, b), [a, b]);
```

## 10. **Props Drilling**
**Problem**: Passing props through multiple levels unnecessarily

**Solution**: Use Context API or state management library
```jsx
// Create context
const UserContext = createContext();

// Provide at top level
<UserContext.Provider value={user}>
  <App />
</UserContext.Provider>

// Consume anywhere
const user = useContext(UserContext);
```

## Prevention Tips:

1. **Use ESLint with React Hooks plugin**
   ```json
   "eslintConfig": {
     "extends": [
       "react-app",
       "plugin:react-hooks/recommended"
     ]
   }
   ```

2. **Enable Strict Mode** to detect side effects
   ```jsx
   <React.StrictMode>
     <App />
   </React.StrictMode>
   ```

3. **Use TypeScript** to catch type-related errors early

4. **Write tests** for components, especially for complex state logic

5. **Use React DevTools** to:
   - Inspect component hierarchy
   - Profile performance
   - Debug hooks and state

6. **Implement error boundaries** to catch runtime errors
   ```jsx
   class ErrorBoundary extends React.Component {
     state = { hasError: false };
     
     static getDerivedStateFromError(error) {
       return { hasError: true };
     }
     
     render() {
       if (this.state.hasError) {
         return <h1>Something went wrong.</h1>;
       }
       return this.props.children;
     }
   }
   ```

7. **Keep components small and focused** (Single Responsibility Principle)

8. **Use custom hooks** to extract and reuse logic

9. **Memoize expensive calculations** with `useMemo`

10. **Virtualize long lists** with libraries like `react-window`