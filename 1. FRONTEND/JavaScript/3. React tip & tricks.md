Here are smart tips and techniques for writing effective React code:

## 1. **Component Design & Structure**

```jsx
// ✅ Do: Small, focused components
const UserProfile = ({ user }) => (
  <div>
    <Avatar src={user.avatar} />
    <UserInfo name={user.name} role={user.role} />
  </div>
);

// ❌ Avoid: Large, monolithic components
const UserProfile = ({ user }) => (
  <div>
    <img src={user.avatar} />
    <div>{user.name}</div>
    <div>{user.role}</div>
    // ... 200 more lines
  </div>
);
```

## 2. **State Management Strategy**

```jsx
// Use custom hooks for complex state logic
const useForm = (initialValues) => {
  const [values, setValues] = useState(initialValues);
  
  const handleChange = useCallback((e) => {
    const { name, value } = e.target;
    setValues(prev => ({ ...prev, [name]: value }));
  }, []);

  return [values, handleChange];
};

// Choose right state location:
// - Local: useState
// - Component tree: useContext + useReducer
// - App-wide: Zustand/Redux Toolkit
```

## 3. **Performance Optimization**

```jsx
// Memoize expensive computations
const ExpensiveComponent = React.memo(({ data }) => {
  const processedData = useMemo(() => 
    expensiveCalculation(data), [data]
  );
  
  const handleClick = useCallback(() => {
    // event handler
  }, [dependencies]);
  
  return <div>{processedData}</div>;
});
```

## 4. **Effect Management**

```jsx
// Clean up effects properly
useEffect(() => {
  const controller = new AbortController();
  
  fetchData(id, { signal: controller.signal })
    .then(setData)
    .catch(setError);

  return () => controller.abort(); // Cleanup
}, [id]);
```

## 5. **Type Safety**

```jsx
// Use TypeScript or PropTypes
interface UserCardProps {
  user: {
    id: string;
    name: string;
    email?: string;
  };
  onEdit: (id: string) => void;
}

const UserCard: React.FC<UserCardProps> = ({ user, onEdit }) => {
  // Type-safe code
};
```

## 6. **Error Handling**

```jsx
// Use Error Boundaries
class ErrorBoundary extends React.Component {
  state = { hasError: false };
  
  static getDerivedStateFromError() {
    return { hasError: true };
  }
  
  componentDidCatch(error, errorInfo) {
    logErrorToService(error, errorInfo);
  }
  
  render() {
    if (this.state.hasError) {
      return <FallbackUI />;
    }
    return this.props.children;
  }
}
```

## 7. **Testing Strategy**

```jsx
// Write testable components
export const Button = ({ onClick, children, disabled }) => (
  <button 
    onClick={onClick} 
    disabled={disabled}
    data-testid="custom-button"
  >
    {children}
  </button>
);

// Tests:
test('button triggers onClick', () => {
  const handleClick = jest.fn();
  render(<Button onClick={handleClick}>Click</Button>);
  fireEvent.click(screen.getByTestId('custom-button'));
  expect(handleClick).toHaveBeenCalled();
});
```

## 8. **Code Organization**

```
src/
├── components/
│   ├── common/          # Reusable UI components
│   ├── features/        # Feature-specific components
│   └── layouts/         # Layout components
├── hooks/              # Custom hooks
├── utils/              # Helper functions
├── services/           # API calls, external services
├── stores/             # State management
├── types/              # TypeScript definitions
└── assets/             # Images, fonts, etc.
```

## 9. **Smart Rendering Patterns**

```jsx
// Conditional rendering techniques
const UserStatus = ({ user }) => {
  if (!user) return <LoadingSkeleton />;
  if (user.error) return <ErrorState />;
  if (user.isEmpty) return <EmptyState />;
  
  return <UserProfile user={user} />;
};

// Render props pattern
const DataFetcher = ({ children, url }) => {
  const [data, setData] = useState(null);
  
  useEffect(() => {
    fetch(url).then(res => setData(res.json()));
  }, [url]);
  
  return children(data);
};

// Usage:
<DataFetcher url="/api/users">
  {data => data && <UserList users={data} />}
</DataFetcher>
```

## 10. **Development Practices**

- **Use React DevTools** for debugging
- **Implement code splitting** with `React.lazy()`
- **Follow the principle of least privilege** for component access
- **Keep components pure** when possible
- **Use descriptive component and variable names**
- **Document complex logic** with comments
- **Implement proper loading and error states**
- **Optimize bundle size** with tree shaking

## 11. **Modern Patterns**

```jsx
// Compound components
const Tabs = ({ children }) => {
  const [activeTab, setActiveTab] = useState(0);
  
  return (
    <TabsContext.Provider value={{ activeTab, setActiveTab }}>
      {children}
    </TabsContext.Provider>
  );
};

Tabs.Tab = TabComponent;
Tabs.Panel = TabPanelComponent;

// Usage:
<Tabs>
  <Tabs.Tab>Tab 1</Tabs.Tab>
  <Tabs.Tab>Tab 2</Tabs.Tab>
  <Tabs.Panel>Content 1</Tabs.Panel>
  <Tabs.Panel>Content 2</Tabs.Panel>
</Tabs>
```

## 12. **Tooling & Automation**

- Use **ESLint** with React-specific rules
- Set up **Prettier** for consistent formatting
- Implement **Husky** for pre-commit hooks
- Use **React Query/SWR** for server state
- Consider **Next.js** for SSR/SSG projects

## Key Principles:

1. **Single Responsibility**: Each component should do one thing well
2. **Composition Over Inheritance**: Build complex UIs from simple components
3. **Declarative Code**: Describe what should happen, not how
4. **Predictable State**: State updates should be pure and predictable
5. **Progressive Enhancement**: Start simple, add complexity as needed

Remember: The best React code is **readable, maintainable, and predictable**. Always prioritize clarity over cleverness unless performance demands it.
