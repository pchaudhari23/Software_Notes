
50 JavaScript Code Snippet Interview Questions

Output-Based Questions

1. Variable Hoisting

```javascript
console.log(a);
var a = 5;
console.log(b);
let b = 10;
```

Answer:

```
undefined
ReferenceError: Cannot access 'b' before initialization
```

Variable a is hoisted with undefined, but b is in TDZ (Temporal Dead Zone) when accessed.

---

2. Function Hoisting

```javascript
foo();
function foo() {
    console.log("First");
}
foo();
function foo() {
    console.log("Second");
}
```

Answer:

```
Second
Second
```

Function declarations are hoisted, and the second definition overwrites the first.

---

3. Closure with var in Loop

```javascript
for (var i = 0; i < 3; i++) {
    setTimeout(() => console.log(i), 0);
}
```

Answer:

```
3
3
3
```

var has function scope, so all timeouts share the same i after the loop completes.

---

4. Closure with let in Loop

```javascript
for (let i = 0; i < 3; i++) {
    setTimeout(() => console.log(i), 0);
}
```

Answer:

```
0
1
2
```

let has block scope, creating a new binding for each iteration.

---

5. this in Arrow Function

```javascript
const obj = {
    name: "Alice",
    greet: () => {
        console.log(`Hello, ${this.name}`);
    }
};
obj.greet();
```

Answer:

```
Hello, undefined
```

Arrow functions don't have their own this, they inherit from parent scope (global/window).

---

6. this in Regular Function

```javascript
const obj = {
    name: "Bob",
    greet: function() {
        console.log(`Hello, ${this.name}`);
    }
};
const greet = obj.greet;
greet();
```

Answer:

```
Hello, undefined
```

When called without context, this refers to global object (or undefined in strict mode).

---

7. setTimeout with this

```javascript
const obj = {
    value: 42,
    getValue: function() {
        setTimeout(function() {
            console.log(this.value);
        }, 0);
    }
};
obj.getValue();
```

Answer:

```
undefined
```

Callback's this is not bound to obj; it defaults to global/window.

---

8. Implicit Type Conversion

```javascript
console.log(1 + "2" + "2");
console.log(1 + +"2" + "2");
console.log(1 + -"1" + "2");
console.log(+"1" + "1" + "2");
```

Answer:

```
"122"
"32"
"02"
"112"
```

+ with string concatenates; unary + converts to number.

---

9. Boolean Coercion

```javascript
console.log(Boolean("false"));
console.log(Boolean(false));
console.log("false" == false);
```

Answer:

```
true
false
false
```

Non-empty string is truthy; == does type coercion (string "false" becomes NaN).

---

10. Array Comparison

```javascript
console.log([] == ![]);
console.log([] == 0);
console.log([[]] == 0);
console.log([] == []);
```

Answer:

```
true
true
true
false
```

Type coercion rules: ![] is false, [] converts to "" then 0. Arrays are reference types.

---

11. Object Property Keys

```javascript
const obj = {
    1: "one",
    "1": "two",
    [1]: "three"
};
console.log(obj[1]);
console.log(Object.keys(obj));
```

Answer:

```
three
["1"]
```

Numeric keys are converted to strings; duplicate keys overwrite.

---

12. NaN Comparison

```javascript
console.log(NaN === NaN);
console.log(Object.is(NaN, NaN));
console.log(isNaN("string"));
console.log(Number.isNaN("string"));
```

Answer:

```
false
true
true
false
```

NaN is never equal to itself; isNaN coerces, Number.isNaN doesn't.

---

13. Scope Chain

```javascript
var x = 10;
function foo() {
    console.log(x);
    var x = 20;
}
foo();
```

Answer:

```
undefined
```

Local x is hoisted within function, shadowing outer x.

---

14. Function vs Block Scope

```javascript
if (true) {
    var a = 1;
    let b = 2;
    const c = 3;
}
console.log(a);
console.log(b);
console.log(c);
```

Answer:

```
1
ReferenceError: b is not defined
```

var is function-scoped, let/const are block-scoped.

---

15. Template Literals

```javascript
const a = 5;
const b = 10;
console.log(`Sum is ${a + b}`);
console.log(`Result is ${a * b}`);
```

Answer:

```
Sum is 15
Result is 50
```

Template literals evaluate expressions inside ${}.

---

16. Object Reference

```javascript
let obj1 = { value: 10 };
let obj2 = obj1;
let obj3 = { value: 10 };
obj1.value = 20;
console.log(obj2.value);
console.log(obj1 == obj3);
```

Answer:

```
20
false
```

Objects are reference types; equality checks reference, not content.

---

17. Array Methods - map

```javascript
const arr = [1, 2, 3];
const result = arr.map(num => {
    if (num > 1) return num * 2;
});
console.log(result);
```

Answer:

```
[undefined, 4, 6]
```

map returns undefined for elements without explicit return.

---

18. Array Methods - reduce

```javascript
const arr = [1, 2, 3, 4];
const sum = arr.reduce((acc, curr) => {
    if (curr % 2 === 0) return acc + curr;
    return acc;
});
console.log(sum);
```

Answer:

```
6
```

Accumulator starts at first element (1) when no initial value provided.

---

19. Promise Microtask Queue

```javascript
console.log("Start");
setTimeout(() => console.log("Timeout"), 0);
Promise.resolve().then(() => console.log("Promise"));
console.log("End");
```

Answer:

```
Start
End
Promise
Timeout
```

Promise callbacks go to microtask queue (higher priority than macrotask).

---

20. Promise Chaining

```javascript
Promise.resolve(1)
    .then(x => x + 1)
    .then(x => { throw new Error("Error!") })
    .catch(() => 3)
    .then(x => x + 1)
    .then(x => console.log(x));
```

Answer:

```
4
```

Error is caught and chain continues with value 3.

---

21. async/await

```javascript
async function foo() {
    return await Promise.resolve("Hello");
}
foo().then(console.log);
```

Answer:

```
Hello
```

async functions return promises; await unwraps promises.

---

22. Generator Function

```javascript
function* generator() {
    yield 1;
    yield 2;
    yield 3;
}
const gen = generator();
console.log(gen.next().value);
console.log(gen.next().value);
console.log(gen.next().value);
```

Answer:

```
1
2
3
```

Generators yield values one at a time with next().

---

23. Event Loop - Order

```javascript
setTimeout(() => console.log(1), 0);
Promise.resolve().then(() => console.log(2));
console.log(3);
```

Answer:

```
3
2
1
```

Sync code ‚Üí Microtasks ‚Üí Macrotasks.

---

24. Object.freeze

```javascript
const obj = { a: 1, b: { c: 2 } };
Object.freeze(obj);
obj.a = 10;
obj.b.c = 20;
console.log(obj);
```

Answer:

```
{ a: 1, b: { c: 20 } }
```

freeze is shallow; nested objects can be modified.

---

25. Prototype Chain

```javascript
function Animal() {}
Animal.prototype.speak = function() {
    return "Animal sound";
};
const dog = new Animal();
console.log(dog.speak());
delete dog.speak;
console.log(dog.speak());
```

Answer:

```
Animal sound
Animal sound
```

Method is on prototype, not instance. Delete doesn't affect prototype.

---

26. Class Inheritance

```javascript
class Animal {
    constructor(name) {
        this.name = name;
    }
    speak() {
        console.log(`${this.name} makes a noise`);
    }
}
class Dog extends Animal {
    speak() {
        console.log(`${this.name} barks`);
    }
}
const d = new Dog("Rex");
d.speak();
```

Answer:

```
Rex barks
```

Child class method overrides parent method.

---

27. Rest Parameters

```javascript
function sum(...args) {
    return args.reduce((a, b) => a + b, 0);
}
console.log(sum(1, 2, 3, 4));
```

Answer:

```
10
```

Rest parameter collects all arguments into an array.

---

28. Spread Operator

```javascript
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
const merged = [...arr1, ...arr2];
console.log(merged);
```

Answer:

```
[1, 2, 3, 4, 5, 6]
```

Spread operator expands array elements.

---

29. Destructuring

```javascript
const [a, , b] = [1, 2, 3, 4];
const { x: y } = { x: 5 };
console.log(a, b, y);
```

Answer:

```
1 3 5
```

Array skipping and object property renaming.

---

30. Default Parameters

```javascript
function multiply(a, b = 1) {
    return a * b;
}
console.log(multiply(5));
console.log(multiply(5, undefined));
console.log(multiply(5, null));
```

Answer:

```
5
5
0
```

null is explicitly passed, not undefined, so default doesn't apply.

---

Error-Spotting Questions

31. Const Reassignment

```javascript
const PI = 3.14;
PI = 3.14159;
console.log(PI);
```

Answer:

```
TypeError: Assignment to constant variable
```

const variables cannot be reassigned.

---

32. Missing new with Constructor

```javascript
function Person(name) {
    this.name = name;
}
const bob = Person("Bob");
console.log(bob);
```

Answer:

```
undefined
```

Without new, this refers to global object and function returns undefined.

---

33. Strict Mode

```javascript
"use strict";
function test() {
    undeclaredVar = 10;
}
test();
```

Answer:

```
ReferenceError: undeclaredVar is not defined
```

Strict mode prevents implicit global variable creation.

---

34. JSON.parse Error

```javascript
const json = '{ "name": "John", age: 30 }';
const obj = JSON.parse(json);
```

Answer:

```
SyntaxError: Unexpected token a in JSON at position 16
```

Property names must be quoted in JSON.

---

35. delete Operator

```javascript
const obj = { a: 1, b: 2 };
delete obj.a;
delete obj.c;
delete Object.prototype;
```

Answer:
Can't delete Object.prototype (returns false in non-strict mode, error in strict).

---

36. Hoisting with Function Expression

```javascript
foo();
var foo = function() {
    console.log("Hello");
};
```

Answer:

```
TypeError: foo is not a function
```

Variable foo is hoisted as undefined, not as a function.

---

37. parseInt Issues

```javascript
console.log(parseInt("08"));
console.log(parseInt("08", 10));
```

Answer:

```
8 (or 0 in older browsers)
8
```

Without radix, leading zero may cause octal interpretation in older JS.

---

38. for...in with Array

```javascript
Array.prototype.custom = function() {};
const arr = [1, 2, 3];
for (let i in arr) {
    console.log(i);
}
```

Answer:

```
0
1
2
custom
```

for...in iterates over enumerable properties including inherited ones.

---

39. Function Name Conflict

```javascript
function foo(a, a) {
    console.log(a);
}
foo(1, 2);
```

Answer:

```
2
```

In non-strict mode, duplicate parameters allowed; last value wins.

---

40. eval Scope

```javascript
var x = 2;
function test() {
    var x = 1;
    eval("var x = 5; console.log(x)");
    console.log(x);
}
test();
console.log(x);
```

Answer:

```
5
5
2
```

eval in non-strict mode can modify local scope.

---

41. with Statement

```javascript
const obj = { a: 1, b: 2 };
with (obj) {
    console.log(a + b);
    c = 3;
}
console.log(obj.c);
```

Answer:

```
3
undefined
```

with is deprecated; c becomes global variable, not property of obj.

---

42. Labeled Break

```javascript
outer: for (let i = 0; i < 3; i++) {
    for (let j = 0; j < 3; j++) {
        if (i === 1 && j === 1) break outer;
        console.log(i, j);
    }
}
```

Answer:

```
0 0
0 1
0 2
1 0
```

Labeled break exits outer loop when condition met.

---

43. arguments Object

```javascript
function foo(a, b) {
    arguments[0] = 10;
    console.log(a);
    arguments.length = 1;
    console.log(b);
}
foo(1, 2);
```

Answer:

```
10
undefined
```

arguments is array-like; modifying it affects parameters (in non-strict mode).

---

44. Symbol Type

```javascript
const sym1 = Symbol("key");
const sym2 = Symbol("key");
const obj = {
    [sym1]: "value1",
    [sym2]: "value2"
};
console.log(obj[sym1]);
console.log(obj[sym2]);
console.log(Symbol.keyFor(sym1));
```

Answer:

```
value1
value2
undefined
```

Symbols are unique; keyFor only works for global symbols.

---

45. Proxy get Trap

```javascript
const target = { message: "hello" };
const handler = {
    get: function(obj, prop) {
        return prop in obj ? obj[prop] : `Property ${prop} not found`;
    }
};
const proxy = new Proxy(target, handler);
console.log(proxy.message);
console.logproxy.undefinedProperty);
```

Answer:

```
hello
Property undefinedProperty not found
```

Proxy can intercept property access.

---

46. WeakMap

```javascript
let obj = { data: "important" };
const weakMap = new WeakMap();
weakMap.set(obj, "metadata");
obj = null;
console.log(weakMap.has(obj));
```

Answer:

```
false
```

WeakMap holds weak references; object can be garbage collected.

---

47. BigInt

```javascript
const big = 9007199254740991n;
const num = 9007199254740991;
console.log(big + 1n);
console.log(num + 1);
console.log(big == num);
console.log(big === num);
```

Answer:

```
9007199254740992n
9007199254740992
true
false
```

BigInt avoids precision loss; equality vs strict equality differs.

---

48. Optional Chaining

```javascript
const obj = { a: { b: { c: 1 } } };
console.log(obj?.a?.b?.c);
console.log(obj?.a?.b?.c?.d);
console.log(obj?.x?.y?.z);
```

Answer:

```
1
undefined
undefined
```

Optional chaining short-circuits to undefined on null/undefined.

---

49. Nullish Coalescing

```javascript
console.log(0 ?? "default");
console.log("" ?? "default");
console.log(null ?? "default");
console.log(undefined ?? "default");
```

Answer:

```
0
""
default
default
```

Only null or undefined trigger the default with ??.

---

50. import() Dynamic Import

```javascript
// Assuming module.js exports: export const value = 42;
async function loadModule() {
    const module = await import('./module.js');
    console.log(module.value);
}
loadModule();
```

Answer:

```
42
```

Dynamic import returns a promise; exports are accessed as module properties.

---

Key Concepts Covered:

1. Hoisting & Temporal Dead Zone
2. Closures & Scopes
3. this binding
4. Type Coercion
5. Prototypes & Inheritance
6. Asynchronous JS (Promises, async/await)
7. ES6+ Features
8. Common Pitfalls
9. Error Handling
10. Advanced Concepts (Proxies, WeakMaps, etc.)

These questions test fundamental JavaScript knowledge that's crucial for interviews. Practice understanding the why behind each answer, not just memorizing outputs!

-----

50 React Code Snippet Interview Questions

Output-Based Questions

1. useState Initialization

```jsx
function Counter() {
  const [count, setCount] = useState(0);
  
  const increment = () => {
    setCount(count + 1);
    setCount(count + 1);
  };
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>Increment</button>
    </div>
  );
}
```

Answer: Clicking increments by 1, not 2. setState is asynchronous and uses stale state in same render.

---

2. useState with Functional Update

```jsx
function Counter() {
  const [count, setCount] = useState(0);
  
  const increment = () => {
    setCount(prev => prev + 1);
    setCount(prev => prev + 1);
  };
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>Increment</button>
    </div>
  );
}
```

Answer: Clicking increments by 2. Functional updates use latest state.

---

3. useEffect Dependency Array

```jsx
function App() {
  const [count, setCount] = useState(0);
  const [text, setText] = useState('');
  
  useEffect(() => {
    console.log('Effect runs');
  }, [count]);
  
  return (
    <div>
      <button onClick={() => setCount(c => c + 1)}>Count: {count}</button>
      <input value={text} onChange={e => setText(e.target.value)} />
    </div>
  );
}
```

Answer: Effect runs only when count changes, not when text changes.

---

4. useEffect Cleanup

```jsx
function Timer() {
  const [seconds, setSeconds] = useState(0);
  
  useEffect(() => {
    const id = setInterval(() => {
      setSeconds(s => s + 1);
    }, 1000);
    
    return () => clearInterval(id);
  }, []);
  
  return <div>Seconds: {seconds}</div>;
}
```

Answer: Timer increments every second. Cleanup prevents memory leak on unmount.

---

5. useState with Object

```jsx
function UserProfile() {
  const [user, setUser] = useState({ name: 'John', age: 25 });
  
  const updateAge = () => {
    user.age = 30;
    setUser(user);
  };
  
  return (
    <div>
      <p>Name: {user.name}, Age: {user.age}</p>
      <button onClick={updateAge}>Update Age</button>
    </div>
  );
}
```

Answer: Does NOT re-render. Mutating state directly doesn't trigger update. Need new object: setUser({...user, age: 30})

---

6. Multiple useState Calls

```jsx
function Component() {
  console.log('render');
  const [a, setA] = useState(0);
  const [b, setB] = useState(0);
  
  const handleClick = () => {
    setA(1);
    setB(2);
  };
  
  return <button onClick={handleClick}>Click</button>;
}
```

Answer: Only one 'render' log after clicking. React batches state updates.

---

7. useContext

```jsx
const ThemeContext = React.createContext('light');

function App() {
  return (
    <ThemeContext.Provider value="dark">
      <Child />
    </ThemeContext.Provider>
  );
}

function Child() {
  const theme = useContext(ThemeContext);
  return <div>Theme: {theme}</div>;
}
```

Answer: Renders "Theme: dark". useContext accesses nearest Provider value.

---

8. useReducer

```jsx
function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 };
    case 'decrement':
      return { count: state.count - 1 };
    default:
      return state;
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, { count: 0 });
  
  return (
    <div>
      Count: {state.count}
      <button onClick={() => dispatch({ type: 'increment' })}>+</button>
      <button onClick={() => dispatch({ type: 'decrement' })}>-</button>
    </div>
  );
}
```

Answer: Buttons increment/decrement count. useReducer manages complex state logic.

---

9. useCallback Dependency

```jsx
function Parent() {
  const [count, setCount] = useState(0);
  
  const logCount = useCallback(() => {
    console.log(count);
  }, []);
  
  return (
    <div>
      <button onClick={() => setCount(c => c + 1)}>Count: {count}</button>
      <Child logCount={logCount} />
    </div>
  );
}

const Child = React.memo(({ logCount }) => {
  console.log('Child render');
  return <button onClick={logCount}>Log</button>;
});
```

Answer: Clicking Log always logs 0. Missing count dependency in useCallback.

---

10. useMemo

```jsx
function ExpensiveComponent({ a, b }) {
  const result = useMemo(() => {
    console.log('Calculating...');
    return a * b;
  }, [a, b]);
  
  return <div>Result: {result}</div>;
}

function App() {
  const [a, setA] = useState(2);
  const [b, setB] = useState(3);
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <ExpensiveComponent a={a} b={b} />
      <button onClick={() => setCount(c => c + 1)}>Re-render: {count}</button>
    </div>
  );
}
```

Answer: 'Calculating...' logs only when a or b changes, not on count updates.

---

11. React.memo

```jsx
const Child = React.memo(({ value }) => {
  console.log('Child renders');
  return <div>Value: {value}</div>;
});

function Parent() {
  const [count, setCount] = useState(0);
  const [text, setText] = useState('hello');
  
  return (
    <div>
      <button onClick={() => setCount(c => c + 1)}>Count: {count}</button>
      <Child value={text} />
    </div>
  );
}
```

Answer: 'Child renders' logs only once. React.memo prevents re-renders when props don't change.

---

12. useRef Initialization

```jsx
function Counter() {
  const [count, setCount] = useState(0);
  const renderCount = useRef(0);
  
  useEffect(() => {
    renderCount.current = renderCount.current + 1;
  });
  
  return (
    <div>
      <p>Count: {count}</p>
      <p>Renders: {renderCount.current}</p>
      <button onClick={() => setCount(c => c + 1)}>Increment</button>
    </div>
  );
}
```

Answer: Renders show total renders (initial + updates). useRef persists across renders without triggering re-renders.

---

13. useRef vs useState

```jsx
function Component() {
  const [state, setState] = useState(0);
  const ref = useRef(0);
  
  const handleClick = () => {
    setState(state + 1);
    ref.current = ref.current + 1;
    console.log(`state: ${state}, ref: ${ref.current}`);
  };
  
  return (
    <div>
      <button onClick={handleClick}>Click</button>
      <div>State: {state}</div>
      <div>Ref: {ref.current}</div>
    </div>
  );
}
```

Answer: Console shows stale state but updated ref. DOM shows updated state but ref value doesn't trigger re-render.

---

14. forwardRef

```jsx
const Input = React.forwardRef((props, ref) => {
  return <input ref={ref} {...props} />;
});

function Form() {
  const inputRef = useRef();
  
  useEffect(() => {
    inputRef.current.focus();
  }, []);
  
  return <Input ref={inputRef} placeholder="Type here" />;
}
```

Answer: Input gets focus on mount. forwardRef passes ref through component.

---

15. Children Prop

```jsx
function Box({ children }) {
  return (
    <div style={{ border: '1px solid black', padding: '10px' }}>
      {children}
    </div>
  );
}

function App() {
  return (
    <Box>
      <h1>Title</h1>
      <p>Content</p>
    </Box>
  );
}
```

Answer: Renders children inside styled div. children prop contains nested JSX.

---

16. Conditional Rendering

```jsx
function Greeting({ isLoggedIn }) {
  return (
    <div>
      {isLoggedIn ? (
        <h1>Welcome back!</h1>
      ) : (
        <h1>Please sign up.</h1>
      )}
      {isLoggedIn && <button>Logout</button>}
    </div>
  );
}
```

Answer: Shows different content based on isLoggedIn. && operator for conditional rendering.

---

17. List Keys

```jsx
function List() {
  const items = ['Apple', 'Banana', 'Cherry'];
  
  return (
    <ul>
      {items.map((item, index) => (
        <li key={index}>{item}</li>
      ))}
    </ul>
  );
}
```

Answer: Renders list but key={index} causes issues if list reorders. Should use unique IDs.

---

18. Event Pooling (React 16)

```jsx
function Button() {
  const handleClick = (e) => {
    setTimeout(() => {
      console.log(e.type); // What gets logged?
    }, 1000);
  };
  
  return <button onClick={handleClick}>Click</button>;
}
```

Answer: In React 16: null (event pooled). In React 17+: click (no pooling). Need e.persist() in React 16.

---

19. Synthetic Event

```jsx
function Form() {
  const handleSubmit = (e) => {
    e.preventDefault();
    console.log('Form submitted');
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <button type="submit">Submit</button>
    </form>
  );
}
```

Answer: Prevents page reload. e.preventDefault() stops default browser behavior.

---

20. Event Handler with Parameter

```jsx
function List() {
  const items = ['A', 'B', 'C'];
  
  const handleClick = (item) => {
    console.log(item);
  };
  
  return (
    <ul>
      {items.map(item => (
        <li key={item} onClick={() => handleClick(item)}>
          {item}
        </li>
      ))}
    </ul>
  );
}
```

Answer: Clicking logs the item. Arrow function creates new function each render.

---

21. Controlled Component

```jsx
function Input() {
  const [value, setValue] = useState('');
  
  return (
    <input 
      value={value}
      onChange={(e) => setValue(e.target.value)}
    />
  );
}
```

Answer: Input value controlled by React state. value always equals value state.

---

22. Uncontrolled Component

```jsx
function Form() {
  const inputRef = useRef();
  
  const handleSubmit = (e) => {
    e.preventDefault();
    console.log(inputRef.current.value);
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input ref={inputRef} defaultValue="Hello" />
      <button type="submit">Submit</button>
    </form>
  );
}
```

Answer: Uses DOM for state. defaultValue sets initial value only.

---

23. Lazy Loading

```jsx
const HeavyComponent = React.lazy(() => import('./HeavyComponent'));

function App() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <HeavyComponent />
    </Suspense>
  );
}
```

Answer: Shows fallback while component loads. Code-splitting for performance.

---

24. Error Boundary

```jsx
class ErrorBoundary extends React.Component {
  state = { hasError: false };
  
  static getDerivedStateFromError(error) {
    return { hasError: true };
  }
  
  render() {
    if (this.state.hasError) {
      return <h1>Something went wrong.</h1>;
    }
    return this.props.children;
  }
}

function BuggyComponent() {
  throw new Error('I crashed!');
  return <div>Normal render</div>;
}

function App() {
  return (
    <ErrorBoundary>
      <BuggyComponent />
    </ErrorBoundary>
  );
}
```

Answer: Shows "Something went wrong." Error boundaries catch render errors.

---

25. Higher-Order Component

```jsx
function withLogger(WrappedComponent) {
  return function(props) {
    console.log('Rendering:', WrappedComponent.name);
    return <WrappedComponent {...props} />;
  };
}

const Button = ({ label }) => <button>{label}</button>;
const ButtonWithLogger = withLogger(Button);

function App() {
  return <ButtonWithLogger label="Click me" />;
}
```

Answer: Logs "Rendering: Button" then renders button. HOC adds logging behavior.

---

Error-Spotting Questions

26. Rules of Hooks

```jsx
function BadComponent() {
  if (Math.random() > 0.5) {
    const [state, setState] = useState(0);
  }
  
  return <div>Hello</div>;
}
```

Answer: ‚ùå Error: Hooks called conditionally. Must be at top level.

---

27. useState in Loop

```jsx
function BadComponent() {
  for (let i = 0; i < 5; i++) {
    const [state, setState] = useState(0);
  }
  
  return <div>Hello</div>;
}
```

Answer: ‚ùå Error: Hooks called in loop. Must be in same order each render.

---

28. useEffect Missing Dependency

```jsx
function Timer() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    const id = setInterval(() => {
      setCount(count + 1);
    }, 1000);
    
    return () => clearInterval(id);
  }, []); // Missing dependency
  
  return <div>{count}</div>;
}
```

Answer: ‚ö†Ô∏è Bug: Timer stays at 1. Missing count dependency causes stale closure.

---

29. Infinite useEffect Loop

```jsx
function App() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    setCount(count + 1);
  }, [count]); // Causes infinite loop
  
  return <div>{count}</div>;
}
```

Answer: üîÑ Infinite Loop: Effect runs when count changes, then changes count.

---

30. Async useEffect Function

```jsx
useEffect(async () => {
  const data = await fetchData();
  setData(data);
}, []);
```

Answer: ‚ùå Error: useEffect callback cannot be async. Should use async inside:

```jsx
useEffect(() => {
  async function fetch() {
    const data = await fetchData();
    setData(data);
  }
  fetch();
}, []);
```

---

31. useState with Props

```jsx
function Counter({ initialCount }) {
  const [count, setCount] = useState(initialCount);
  
  // What if initialCount prop changes?
  return <div>{count}</div>;
}
```

Answer: ‚ö†Ô∏è Bug: State won't update if initialCount prop changes. Need useEffect to sync:

```jsx
useEffect(() => {
  setCount(initialCount);
}, [initialCount]);
```

---

32. Mutating State Directly

```jsx
function UserList() {
  const [users, setUsers] = useState(['Alice', 'Bob']);
  
  const addUser = () => {
    users.push('Charlie');
    setUsers(users);
  };
  
  return (
    <div>
      {users.map(user => <div>{user}</div>)}
      <button onClick={addUser}>Add</button>
    </div>
  );
}
```

Answer: ‚ö†Ô∏è Bug: Won't re-render. Mutating array directly. Should be:

```jsx
setUsers([...users, 'Charlie']);
```

---

33. Nested Object Mutation

```jsx
function UserProfile() {
  const [user, setUser] = useState({ 
    name: 'John', 
    address: { city: 'NYC' } 
  });
  
  const updateCity = () => {
    user.address.city = 'LA';
    setUser(user);
  };
  
  return <button onClick={updateCity}>Update</button>;
}
```

Answer: ‚ö†Ô∏è Bug: Shallow comparison won't detect nested change. Need deep copy:

```jsx
setUser({
  ...user,
  address: { ...user.address, city: 'LA' }
});
```

---

34. Forgetting to Bind this

```jsx
class Button extends React.Component {
  handleClick() {
    console.log('Clicked');
  }
  
  render() {
    return <button onClick={this.handleClick}>Click</button>;
  }
}
```

Answer: ‚ö†Ô∏è Bug: this is undefined when clicked. Solutions:

1. onClick={this.handleClick.bind(this)}
2. Arrow function: onClick={() => this.handleClick()}
3. Bind in constructor
4. Use class property: handleClick = () => { ... }

---

35. setState in Constructor

```jsx
class Counter extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
    this.setState({ count: 1 }); // Problem here
  }
}
```

Answer: ‚ùå Error: Can't call setState before component mounts. Set directly: this.state = { count: 1 }

---

36. Props Default Value

```jsx
function Greeting({ name }) {
  return <h1>Hello {name}!</h1>;
}

Greeting.defaultProps = {
  name: 'Guest'
};

// What if called like: <Greeting name={undefined} />
```

Answer: Shows "Hello Guest!". defaultProps applies when prop is undefined, not null.

---

37. React.Fragment vs div

```jsx
function Table() {
  return (
    <table>
      <tr>
        <Columns />
      </tr>
    </table>
  );
}

function Columns() {
  return (
    <div>
      <td>Hello</td>
      <td>World</td>
    </div>
  );
}
```

Answer: ‚ùå Error: div inside tr. Should use Fragment:

```jsx
function Columns() {
  return (
    <>
      <td>Hello</td>
      <td>World</td>
    </>
  );
}
```

---

38. Key Prop Warning

```jsx
function List({ items }) {
  return (
    <ul>
      {items.map(item => (
        <li>{item}</li>
      ))}
    </ul>
  );
}
```

Answer: ‚ö†Ô∏è Warning: "Each child in a list should have a unique key prop." Add key={item.id}.

---

39. Memory Leak with setState

```jsx
function Component() {
  const [data, setData] = useState(null);
  
  useEffect(() => {
    fetchData().then(result => {
      setData(result);
    });
  }, []);
  
  // What if component unmounts before fetch completes?
}
```

Answer: ‚ö†Ô∏è Memory Leak: setData called on unmounted component. Cleanup needed:

```jsx
useEffect(() => {
  let mounted = true;
  fetchData().then(result => {
    if (mounted) setData(result);
  });
  return () => { mounted = false; };
}, []);
```

---

40. Event Listener Cleanup

```jsx
function ResizeListener() {
  useEffect(() => {
    const handleResize = () => console.log('resized');
    window.addEventListener('resize', handleResize);
  }, []);
  
  return <div>Resize me</div>;
}
```

Answer: ‚ö†Ô∏è Memory Leak: Event listener not removed. Need cleanup:

```jsx
return () => window.removeEventListener('resize', handleResize);
```

---

41. useCallback without Dependency

```jsx
function Parent() {
  const [count, setCount] = useState(0);
  
  const increment = useCallback(() => {
    setCount(count + 1);
  }, []); // Missing count dependency
  
  return <Child onClick={increment} />;
}
```

Answer: ‚ö†Ô∏è Bug: Always increments to 1. Add [count] dependency or use functional update.

---

42. Stale Closure in Interval

```jsx
function Counter() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    const id = setInterval(() => {
      console.log(count);
    }, 1000);
    return () => clearInterval(id);
  }, []);
  
  return <div>{count}</div>;
}
```

Answer: ‚ö†Ô∏è Bug: Always logs 0. Missing count dependency causes stale closure.

---

43. Multiple Refs Same Element

```jsx
function Input() {
  const ref1 = useRef();
  const ref2 = useRef();
  
  useEffect(() => {
    console.log(ref1.current === ref2.current);
  }, []);
  
  return <input ref={[ref1, ref2]} />;
}
```

Answer: ‚ùå Error: Can't pass array to ref. Use callback ref or merge refs.

---

44. Conditional Hook Return

```jsx
function useCustomHook(condition) {
  if (condition) {
    return useState(0);
  }
  return null;
}
```

Answer: ‚ùå Error: Hook must always return same structure. Conditional returns violate Rules of Hooks.

---

45. useState in Class Component

```jsx
class Counter extends React.Component {
  const [count, setCount] = useState(0); // Error here
  
  render() {
    return <div>{count}</div>;
  }
}
```

Answer: ‚ùå Error: Hooks only work in function components. Use this.state and this.setState.

---

46. useEffect with Object Dependency

```jsx
function App() {
  const [data, setData] = useState({ id: 1 });
  
  useEffect(() => {
    console.log('Data changed');
  }, [data]); // Object dependency
  
  const update = () => {
    setData({ id: 1 }); // Same content, different object
  };
  
  return <button onClick={update}>Update</button>;
}
```

Answer: ‚ö†Ô∏è Runs every time: Objects compared by reference, not value.

---

47. useState with Function Initializer

```jsx
function App() {
  const [state, setState] = useState(() => {
    return expensiveComputation();
  });
  
  // Good - function runs once
  // Bad if you do this:
  const [badState, setBadState] = useState(expensiveComputation());
  // Runs on every render!
}
```

Answer: ‚úÖ Correct: Lazy initializer runs once. ‚ùå Wrong: Direct call runs every render.

---

48. Reconciliation Issue

```jsx
function App() {
  const [show, setShow] = useState(true);
  
  return (
    <div>
      {show ? <input key="first" /> : <input key="first" />}
      <button onClick={() => setShow(!show)}>Toggle</button>
    </div>
  );
}
```

Answer: ‚ö†Ô∏è Bug: Input loses focus on toggle. Same key makes React think it's same element.

---

49. Prop Drilling

```jsx
function App() {
  const [user, setUser] = useState({ name: 'John' });
  
  return (
    <Header user={user} />
  );
}

function Header({ user }) {
  return <Navbar user={user} />;
}

function Navbar({ user }) {
  return <Profile user={user} />;
}

function Profile({ user }) {
  return <div>{user.name}</div>;
}
```

Answer: ‚ö†Ô∏è Prop Drilling: Pass user through multiple levels. Better: Context API.

---

50. Concurrent Features

```jsx
function App() {
  const [query, setQuery] = useState('');
  
  // startTransition for non-urgent updates
  const [isPending, startTransition] = useTransition();
  
  const handleChange = (e) => {
    startTransition(() => {
      setQuery(e.target.value);
    });
  };
  
  return (
    <div>
      <input value={query} onChange={handleChange} />
      {isPending && <span>Loading...</span>}
      <Results query={query} />
    </div>
  );
}
```

Answer: ‚úÖ Concurrent: startTransition marks update as non-urgent, keeping UI responsive.

---

Key React Concepts Covered:

1. Hooks: useState, useEffect, useContext, useReducer, useCallback, useMemo, useRef
2. State Management: Immutability, batching, functional updates
3. Lifecycle: Mounting, updating, unmounting, cleanup
4. Performance: Memoization, lazy loading, code splitting
5. Common Pitfalls: Stale closures, infinite loops, memory leaks
6. Error Handling: Error boundaries, proper error catching
7. Patterns: Controlled vs uncontrolled, render props, HOCs
8. Best Practices: Keys, fragments, prop types, default props
9. Async Operations: Promises, async/await in React
10. New Features: Concurrent Mode, transitions, Suspense

Understanding these snippets helps master React's nuances and avoid common bugs in production!