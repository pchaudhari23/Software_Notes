MONGODB:

- MongoDB is a **distributed, document-oriented NoSQL** database storing data in **JSON-like documents**.
- It internally stores data in **Binary JSON (BSON)** , a binary-encoded format that is faster to parse and supports more data types than JSON.
- It uses a **flexible, schema-less design** so that we can use dynamic data structures. Although we can put **schema validation** using **Mongoose**.
- **High availability** - achieved through replica sets that provide automatic failover and redundancy.
- **Horizontal scaling** - done using sharding to distribute data across multiple servers for large workloads.
- **Aggregation pipeline** - a powerful framework to transform, filter, and analyze data in stages.
- **ACID transactions** - supported since MongoDB 4.0 for multi-document operations, ensuring atomicity, consistency, isolation, and durability.
- **Rich indexing** - supports text, geospatial, compound, and other indexes for faster query performance.
- Current version: v7.x (Dec 2025)

---

CONCEPTS:

- Collections: A group of documents stored together without a fixed schema. It is equivalent to a table in relational databases.
- Documents: A JSON-like structure containing key-value pairs with flexible fields. It is the basic unit of data in MongoDB. A collection is made up of lot of documents. Document is similar to record in structured db.
- BSON: Binary JSON used internally by MongoDB for storage and queries. It supports additional data types and improves performance.
- BSON data types: Includes ObjectId, Date, Decimal128, Binary. These types allow accurate representation of real-world data.
- Schema-less design: MongoDB does not enforce a schema at the database level. However, schema design is handled at the application level.
- Embedding: Related data is stored in the same document. This improves read performance and reduces joins.
- Referencing: Related data is stored in separate documents using references. This avoids data duplication and is useful for large datasets.
- ObjectId: Default value for the \_id field that uniquely identifies a document. It contains timestamp and machine information.
- ObjectId ordering: ObjectIds are roughly time-ordered. This helps in sorting and pagination.
- Index: A data structure that speeds up read queries. Indexes increase storage usage and write cost.
- Aggregation: Query a collection in db and get an id. Then search documents in other collection using same id, kind of like foreign key. Like a join.
- Aggregation framework: Used for data processing and analytics. It works using a pipeline of stages.
- Aggregation pipeline: Each stage processes documents and passes results forward. Common stages include $match, $group, $sort, $project.
- Replica set: A group of MongoDB instances with one primary. Automatic failover occurs if the primary fails.
- TTL index: Automatically deletes documents after a specified time. Commonly used for logs and session data.
- Capped collection: Fixed-size collection that maintains insertion order. Old documents are removed when the size limit is reached.
- GridFS: Used to store large files like videos or images. Files are split into chunks and stored across collections.

---

COMMANDS:

Basic Commands:

- Create a database: use <database_name>;
- Show all databases: show dbs;
- Show current database: db;
- Drop a database: db.dropDatabase();
- Create a collection: db.createCollection("collection_name");
- Show all collections: show collections;
- Drop a collection: db.collection_name.drop();
- List collection stats: db.collection_name.stats();

Create (Insert Operations):

- Insert one document: db.collection_name.insertOne({ key: value });
- Insert multiple documents: db.collection_name.insertMany([{ key1: value1 }, { key2: value2 }]);

Read (Query Operations):

- Find all documents: db.collection_name.find();
- Find documents with a condition: db.collection_name.find({ key: value });
- Find one document: db.collection_name.findOne({ key: value });
- Find with projection: db.collection_name.find({ key: value }, { field1: 1, field2: 1 });
- Find with sorting: db.collection_name.find().sort({ field: 1 });
- Limit the number of documents: db.collection_name.find().limit(5);
- Skip documents (pagination): db.collection_name.find().skip(5).limit(5);
- Count the number of documents: db.collection_name.countDocuments({ key: value });
- Distinct values of a field: db.collection_name.distinct("field_name");

Update (Update Operations):

- Update one document: db.collection_name.updateOne({ filter }, { $set: { field: value } });
- Update multiple documents: db.collection_name.updateMany({ filter }, { $set: { field: value } });
- Replace one document: db.collection_name.replaceOne({ filter }, { newDocument });
- Upsert (update or insert if not found): db.collection_name.updateOne({ filter }, { $set: { field: value } }, { upsert: true });

Delete (Remove Operations):

- Delete one document: db.collection_name.deleteOne({ filter });
- Delete multiple documents: db.collection_name.deleteMany({ filter });

Index Operations:

- Create an index: db.collection_name.createIndex({ field: 1 });
- List all indexes: db.collection_name.getIndexes();
- Drop an index: db.collection_name.dropIndex("index_name");
- Drop all indexes: db.collection_name.dropIndexes();

Aggregation Operations:

- Basic aggregation: db.collection_name.aggregate([ { $match: { key: value } }, { $group: { _id: "$field", total: { $sum: 1 } } } ]);
- Match documents: { $match: { key: value } }$
- $Group documents: { $group: { _id: "$field", total: { $sum: 1 } } }
- Project fields: { $project: { field1: 1, field2: 1 } }
- Sort documents: { $sort: { field: 1 } }
- Limit number of documents: { $limit: 5 }
- Skip documents (pagination): { $skip: 5 }
- Add a new field (using $addFields): { $addFields: { newField: { $sum: ["$field1", "$field2"] } } }
- Lookup (join collections): { $lookup: { from: "otherCollection", localField: "field", foreignField: "field", as: "joinedData" } }
- Unwind an array: { $unwind: "$arrayField" }

Operators and things:

- $lt : less than
- $gt : greater than
- $gte : greater than equal to
- $eq : equal
- $ne : not equal
- $and : Logical AND
- $or : Logical OR
- $in : in
- $nin : not in
- $and : [{condition 1},{condition 2},{condition 3}]
- $or : [{condition 1},{condition 2},{condition 3}]
- {$gt/$lt...:.....}

Data Validation and Schema Operations:

- Enable validation for a collection:
  db.createCollection("collection_name", {
  validator: {
  $jsonSchema: {
  bsonType: "object",
  required: ["field1", "field2"],
  properties: {
  field1: { bsonType: "string" },
  field2: { bsonType: "int" }
  }
  }
  }
  });
- Get collection validation settings: db.collection_name.getValidationLevel();

Backup and Restore Operations:

- Backup a database - bash: mongodump --db <database_name> --out <backup_directory>
- Restore a database - bash: mongorestore --db <database_name> <backup_directory>

Miscellaneous:

- Get current server status: db.serverStatus();
- Get server build information: db.buildInfo();
- List all active operations: db.currentOp();
- Enable or disable profiling: db.setProfilingLevel(2); // 1 for slow queries, 2 for all queries
- To start mongodb: in cmd - mongod
- To use shell: in cmd - mongosh
- To clear screen: cls
- pretty() : to show data properly

---

INSTALLATION & SETUP:

1. MongoDB: Download and install/extract mongodb server setup. Set the path upto bin folder in environment variables.
2. MongoDB Shell
3. MongoDB CLI Tools: mongoimport, mongoexport, mongodump, mongorestore etc. Allow us to perform operations on DB using cli. Same operations can be performed using compass as well.

STEPS:

1. Download mongodb shell and mongodb command line database tools from downloads section of mongodb website.
2. Extract the zip file of both in the same location where mongodb server folder is present in program files
3. Run the exe of the shell file.
4. Set environment variable for both mongodb cli and mongodb shell. Path must be upto inside of bin folder (where exe file is located).

- To start mongodb: in cmd - mongod
- To use shell: in cmd - mongosh
- Taking local backup of mongodb cluster: - Install CLI tools. It should have mongodump - Command: mongodump --uri="connection_string" --out"path_of_folder_where_db_stored_locally" - folder path can be copied from windows explorer address bar
- Restoring the databases from a folder: - mongorestore --uri "mongodb://localhost:27017" --dir "folder_where_local_backup_is_stored"

---

ATLAS & COMPASS:

1. Create organization under atlas account
2. Create projects under organization
3. Create clusters under a project
4. Create Database in clusters

A cluster can have multiple databases and each database can have multiple collections.

Atlas => Organization => Project => Cluster (DB server instance) => Database => Collections

---

OFFICIAL SAMPLE DATASET:

1. When a cluster is created, there is an option to load sample dataset in created cluster.
2. Sample datasets contain various databases with multiple collections.They can be used to experiment and practice.
3. The sample datasets can be downloaded and imported in local db for learning. Eg: sample_mflix, sample_geospatial etc.

OR

1. Download official sample mongodb dataset from github: Sample dataset => https://github.com/neelabalan/mongodb-sample-dataset
2. Import in local db and practice queries

---

LINKS:

- https://www.mongodb.com/developer/products/mongodb/cheat-sheet/?tck=mongodb_ai_chatbot#crud
- https://www.mongodb.com/docs/: MongoDB Documentation, Node js driver & Database manual

---

TOOLS & FRAMEWORKS:

ODM (Object Document Mapping) Framework: To map document objects into a NoSQL database like MongoDB. Eg: Mongoose - Node JS and Mongo DB

- Mongo DB Atlas
- Mongo DB Compass
- Mongo shell, CLI tools
- 3 versions: Cloud based/ Basic/ Free version, Community version, Enterprise version

Connection string:

1. Local: mongodb://username:password@localhost:27017/database_name
2. Remote: mongodb+srv://username:password@cluster0.mongodb.net/mydatabase?retryWrites=true&w=majority

---

MONGOOSE METHODS:

Create (Insert Operations)
db.collection.insertOne(document) => Model.create(document)
db.collection.insertMany(documents) => Model.insertMany(documents)
db.collection.save(document) => document.save() (Mongoose saves an instance, not a method on the model)

Read (Query Operations)
db.collection.find(query) => Model.find(query)
db.collection.findOne(query) => Model.findOne(query)
db.collection.find().limit(5) => Model.find(query).limit(5)
db.collection.find().skip(5).limit(5) => Model.find(query).skip(5).limit(5)
db.collection.find(query, projection) => Model.find(query, projection)
db.collection.countDocuments(query) => Model.countDocuments(query)
db.collection.distinct(field) => Model.distinct(field)

Update (Update Operations)
db.collection.updateOne(query, update) => Model.updateOne(query, update)
db.collection.updateMany(query, update) => Model.updateMany(query, update)
db.collection.update(query, update) => Model.update(query, update)
db.collection.replaceOne(query, newDocument) => Model.replaceOne(query, newDocument)
db.collection.updateOne(query, update, options) => Model.updateOne(query, update, options)
db.collection.updateMany(query, update, options) => Model.updateMany(query, update, options)

Delete (Remove Operations)
db.collection.deleteOne(query) => Model.deleteOne(query)
db.collection.deleteMany(query) => Model.deleteMany(query)
db.collection.remove(query) => Model.deleteMany(query) (Use deleteOne() or deleteMany() for explicit operations)

Aggregation Operations
db.collection.aggregate(pipeline) => Model.aggregate(pipeline)
db.collection.aggregate([{ $match: ... }]) => Model.aggregate([{ $match: ... }])
db.collection.aggregate([{ $group: ... }]) => Model.aggregate([{ $group: ... }])
db.collection.aggregate([{ $project: ... }]) => Model.aggregate([{ $project: ... }])
db.collection.aggregate([{ $sort: ... }]) => Model.aggregate([{ $sort: ... }])

Index Operations
db.collection.createIndex(fields) => Model.createIndex(fields)
db.collection.getIndexes() => Model.listIndexes()
db.collection.dropIndex(indexName) => Model.dropIndex(indexName)
db.collection.dropIndexes() => Model.dropIndexes()

Validation & Schema Operations
db.createCollection("collection_name", { validator: {...} }) => Model.schema.add(...) (to add new schema fields dynamically)
db.collection.getValidationLevel() => Model.schema.options.validator (access schema validation)
db.collection.updateValidator({...}) => Model.set("validate", true) (to trigger validation for updates)

Other Useful Mongoose Methods
db.collection.findOneAndUpdate(query, update) => Model.findOneAndUpdate(query, update)
db.collection.findOneAndDelete(query) => Model.findOneAndDelete(query)
db.collection.findOneAndReplace(query, newDocument) => Model.findOneAndReplace(query, newDocument)
db.collection.findAndModify(query) => Model.findOneAndUpdate(query, update) (with { new: true } option)

---
