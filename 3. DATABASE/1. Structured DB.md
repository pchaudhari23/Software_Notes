DATABASES:

- Database: **Organized collection** of data, which can be **stored** electronically, **retrieved** and **modified**.
- **DBMS (Database Management System)**: Software that **creates, manages, and controls access** to databases (e.g., **MySQL, PostgreSQL, Oracle**).
- The data may be stored **physically** in any **mass storage device** such as flash memory or hard drive, but **logically or virtually**, it is stored in a **database**.
- A person **who works with databases** is called a **Database Admin** or **Database Administrator** or DBA.
- Examples: MySQL(pronounced as my-sequel), Postgre SQL, Procedural SQL, MongoDB, Oracle Database etc.
- Structured Database - SQL: Database => Tables => Records
- Unstructure Database - MongoDB: Database => Collections => Documents

---

SQL: Structured Query Language

- **Relational Database:** A database that stores data in structured tables with predefined relationships.
- SQL databases are **relational databases** that store data in tables with fixed schemas.
- Structured data is stored and handled in database management systems called Relational Database Management System (RDBMS) Eg: MySql.
- Queries are 'fired' in any RDBMS to retrive the data and the fired query 'hits' a particular table in the database.
- SQL can execute queries against a database. It can retrieve data from a database, insert, update, delete records in a database.
- It can create new databases, create new tables in databases, create stored procedures in database, create views in database, can set permissions on tables, procedures, and views.

---

CONCEPTS:

- Table: A structured collection of rows and columns used in relational databases. Tables are related to each other in some way, hence the name 'Relational DBMS'. In RDBMS like MySQL data is stored in the form of database objects called tables. A database can contain multiple tables.
- Row/Record: Horizontal entry, individual entry in a table representing one entity instance.
- Column/Field: Vertical entity, an attribute for all the records that holds same type of data for all records.
- Database schema: The logical structure of a database that defines tables (or collections), columns (or fields), data types, relationships, and constraints. SQL databases have fixed or strict schema. NoSQL databases usually have flexible schema or no schema.
- Entity Relationship: Logical connection between data entities in a relational database. Eg.: One to one, One to many, Many to many. ER diagrams are visual representation of how entity (a real world object or concept) relates to each other. Various tools & softwares are available to create ER diagrams.
- Database design: Process of defining the structure of DB, entities and relationships with each other. ER diagrams focus on database design, UML (Unified Modeling Language) focus on classes in the system design.
- Requirements => Entities => Keys => Relationships => Normalization => ER Diagram => Implementation
- Seeding the database: Populating the database with some initial dummy data to have some data to work with during development.
- Views: Virtual tables created from SQL queries.
- Stored Procedures: Precompiled SQL code stored in the database.
- Triggers: Automatically executed code on insert/update/delete events.

---

KEYS: A key is an attribute/column or set of attributes/columns used to **uniquely identify records** in a table and to **establish relationships** between tables.

1. Primary key: A column (or combination of columns) that uniquely identifies each row in a table. It **cannot contain NULL values** and must be unique.
2. Foreign key: A column in one table that refers to the **primary key of another table**. It is used to **maintain relationships and referential integrity** .
3. Composite key: A primary key formed using **multiple columns** when a single column is not sufficient for uniqueness.
4. Candidate key: Columns that can uniquely identify a row. One of them is chosen as the primary key.
5. Unique key
6. Alternate key

---

JOINS: A SQL operation used to **combine rows from two or more tables** based on a related column.

1. Inner join: Returns only the records that have **matching values** in both tables.
2. Left join/ Left outer join: Returns all records from the **left table** and matching records from the right table. Non-matching rows from the right table return NULL.
3. Right join/ Right outer join: Returns all records from the **right table** and matching records from the left table. Non-matching rows from the left table return NULL.
4. Full join/ Full outer join: Returns all records when there is a match in **either** table. Non-matching rows return NULL on the missing side. (full join is not supported in MySql, use keyword 'union')
5. Self join
6. Cross join
7. Natural join
8. Hash join

---

NORMALIZATION: Process of **organizing data** in a database to **reduce redundancy,** **eliminate duplicate data** and **improve data integrity** .

Normal Forms:

1. 1NF (First Normal Form): Atomic values (no repeating groups or multi-valued attributes). Each column contains single values only
2. 2NF (Second Normal Form): Must be in 1NF. No partial dependency (non-key attribute should depend on the entire primary key)
3. 3NF (Third Normal Form): Must be in 2NF. No transitive dependency (non-key attributes should not depend on other non-key attributes)

DENORMALIZATION: Process of **intentionally introducing redundancy** into a database to **improve read performance**.

---

PERFORMANCE:

Analogy:

Let's consider an analogy for software. Say I give you 10 books of 1000 pages each. And ask you a question whose answer lies in one of the books. You would: Case 1: Start reading from book 1 and say you find the answer somewhere on page 720 in book 7. So the time taken to read first six books was wasted. Also this time is variable. Say a questions answer could be in first book another would be in last book. Case 2: Another case - you don't read all books yourself but distribute it with ten friends. In this scenario only the friend reading answer containing book has done worthy effort others efforts are wasted. Case 3: You give appendix at end of all the books. This way there is less time required to search for a wore on page, but still in this all the ten people have to search appendix. Case 4: Tear appendix from all books and store it in one book. And another person say master has that appendix book. Now when a question is asked he looks up in appendix and finds which book has answer and only that guy has to search it.

Analysis:

Case 1 – Full Table Scan: Linear search

- No index exists, so the database reads every row sequentially.
- Query time is proportional to table size (O(N)).
- Most data read does not contribute to the final answer.

Case 2 – Parallel Full Table Scan

- Table is scanned simultaneously by multiple CPU cores or nodes.
- Response time improves, but total work remains the same.
- Most parallel workers still perform unnecessary reads.

Case 3 – Local Index per Partition

- Each shard has its own index to speed up local searches.
- Query is still sent to all shards due to lack of global routing.
- Only one shard returns results; others do wasted index lookups.

Case 4 – Global Index with Query Planner

- Central index and metadata identify the correct shard and index.
- Only relevant data is accessed using index seeks (O(log N)).
- Minimal I/O and CPU usage with predictable query performance.

---

INDEXING: Indexing is a technique used to **speed up data retrieval** from a database.

**How it works:**

- Creates a data structure (usually B-tree or Hash)
- Allows faster search instead of full table scan

**Types of indexes:**

- **Primary Index:** Index created automatically on primary key.
- **Secondary Index:** Index created on non-primary columns.
- **Composite Index:** Index created on multiple columns (order matters).
- **Clustered Index:** Determines physical order of data storage.
- **Non-clustered Index:** Separate structure pointing to table rows.

---

TRANSACTIONS: A transaction is a **sequence of database operations** performed as a **single logical unit of work** .

ACID: Atomicity, Consistency, Isolation, Durability.

- **Atomicity:** Ensures all operations in a transaction succeed or fail together.
- **Consistency:** Ensures the database moves from one valid state to another.
- **Isolation:** Ensures concurrent transactions do not interfere with each other.
- **Durability:** Ensures committed data is permanently stored.

---

REPLICATION: Replication is the process of **copying data from one database server to another**. Often done by adding read replica. Master handles the writes and replica need to be kept in sync.

PARTITIONING: Dividing a **single large table** into smaller pieces. Still resides on the same database server. Improves query performance and manageability.

SHARDING: Distributing data **across multiple database servers.** Each shard holds a subset of data. Used in large-scale, high-traffic systems Distribution done based on shard key. Poor shard key can lead to perfomance issue.

RAID: RAID is a **data storage technology** that combines **multiple physical disks** into a **single logical unit** to improve **performance**, **fault tolerance**, or **both**.

---

COMMANDS:

1. SQL Data Types: INT, VARCHAR, CHAR, DATE, TIMESTAMP, DECIMAL, BOOLEAN.
2. DML (Data Manipulation Language) - Select, Update, Insert, Delete (SUID)
3. DDL (Data Defination Language) - Drop, Alter, Create, Truncate (DACT)
4. DCL (Data Control Language) - Grant, Revoke (GR)
5. TCL (Transaction Control Language) - Savepoint, Rollback, Commit (SCR)

Basic Commands:

- mysql>show databases; - to display existing databases
- mysql>create database test; - to create a new database named 'test'
- mysql>use test; - to switch to the database 'test'
- mysql>show tables; - to display all the tables of the current database
- mysql>source C:\Users\admin\Desktop\Db\demobld.sql (don't give semicolon at the end!!!) - to load a readymade database in MySql (in this case, 'demobld')
- mysql>select \* from emp; - to display the whole 'emp' table present in some database
- mysql> desc emp; - describe the 'emp' table as in display it's columns and their constraints
- creating new table column : ColumnName - DataType - Constraints. Eg: DeptId int NOT NULL, UNIQUE

CREATE:

- CREATE DATABASE db_name
- CREATE TABLE table_name (col_1, col_2, ...)
- INSERT INTO table_name VALUES (value1, value2, value3, ...);
- INSERT INTO table_name (column1, column2, column3, ...) VALUES (value1, value2, value3, ...);

READ:

- SELECT _ FROM table_name; (_ means wildcard character, it returns all records)
- SELECT col_1, col_2, col_3 FROM table_name WHERE condition;

UPDATE:

- UPDATE table_name SET column1 = value1, column2 = value2, ... WHERE condition;

DELETE:

- DELETE FROM table_name WHERE condition;
- DELETE FROM table_name; (deletes entire table)

Operators:

1. AND : Logical AND
2. OR : Logical OR

Aggregate functions:

1. sum(...); - returns sum of elements of the argument column.
2. avg(...); - returns average of elements of the argument column.
3. max(...); - returns maximum value of the elements of the argument column
4. min(...); - returns minimum value of the elements of the argument column.
5. count(...); - returns the count or the number of elements of the argument column.

Keywords to be used:

- where......in (.... , .... , ....);
- where......not in (.... , .... , ....);
- where......or ..........;
- where......and..........;
- where......between ....and.......;
- where......between ....or .......;
- where......like.......;
- having........
- group by .....having......;
- order by .....having......;
- concat(left(.... , ....),'....',right(.... , .....), '....');

SET OPERATIONS IN SQL:

1. UNION
2. UNION ALL
3. INTERSECT
4. MINUS

SQL CONSTRAINTS:

1. UNIQUE
2. NOT NULL
3. CHECK
4. DEFAULT
5. INDEX (As in clustering index and non clustering index)

OTHER:

1. use -- for single line commment
2. use /_ ........ _/ for multiline comment
3. floor() - round figure to lower side
4. ceil() - round figure to higher side
5. curdate() - returns current date
6. getdate() - returns date and time

---

TOOLS & FRAMEWORKS:

ORM (Object Relational Mapping) Framework: To map object into a relational db.

1. Hibernate - JAVA
2. Entity framework - .NET
3. Sequalise - Node Js

Database management tools: (Alternatives to CLI)

1. Mongodb compass
2. DBeaver
3. MySQL workbench
4. Microsoft SQL Server Management Studio (SSMS)

---
